////
- Copyright (c) 2025, Sascha Willems
-
- SPDX-License-Identifier: Apache-2.0
-
- Licensed under the Apache License, Version 2.0 the "License";
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-
////
= Navigating the Vulkan Samples
:pp: {plus}{plus}

== Introduction

Vulkan has been released in 2016 as cross-platform low-level graphics api. And esp. the cross-platform aspect, which results in a wide range of devices to be supported (mobile, desktop, embedded, game consoles), can make getting into Vulkan somewhat daunting.

On top of that a lot of new functionality has been added to Vulkan since it's release. This includes multiple new core version (Vulkan 1.1, 1.2, 1.3 and 1.4) and dozends of new extensions.

With the samples we try cover a large portion of what Vulkan is and what Vulkan can do. This includes basic functionalit, but also very specific use cases that some Vulkan developers never have to deal with.

To help with that, this document is meant to help navigate the samples from different perspectives.

== Vulkan header variants

While all samples use C{pp} as a programming language, most of them use the Vulkan C-bindings in `vulkan.h`. But many samples also have variants using the Vulkan C{pp}-bindings in `vulkan.hpp`, which is a more object-oriented variation that saves a lot of boilerplate reuired with the C-bindings. Which variant to choose is mostly a personal choice, but the variants using Vulkan C{pp}-bindings might feel more natural to C{pp} programmers.

== Navigating the samples

=== Starting out

The xref:../samples/api/README.adoc[API samples] show the basic usage of Vulkan. If you are on a newer device that supports Vulkan 1.3, start with the xref:../samples/api/hello_triangle_1_3/README.adoc[Vulkan 1.3 hello triangle sample]. This shows how to use Vulkan in a more modern way with functionality like dynamic rendering to replace render passes. If you're on an older device, a good starting point is the xref:../samples/api/hello_triangle/README.adoc[Vulkan 1.0 hello triangle sample]. Both samples teach how to get your first triangle on the screen.

As most Vulkan applications are going to use textures at some point, so a good next step would be looking at the xref:../samples/api/texture_loading/README.adoc[texture loading] and xref:../samples/api/texture_mipmap_generation/README.adoc[texture mip map generation] samples.

// @todo: next step performance samples, mention high-level framework

=== Returning to Vulkan

A lot has changed since the initial Vulkan 1.0 release. The api evolved and new features that e.g. generally improve the api have been introduced. On such feature is dynamic rendering to replace the old render pass interface for which we have a xref:../samples/api/dynamic_rendering/README.adoc[a basic sample] and xref:../samples/api/dynamic_rendering_local_read/README.adoc[another sample] that shows how to use local reads to replace sub passes with input attachments.

Another advancement is dynamic state to make pipeline creation more flexible. Multiple samples demonstrates xref:../samples/api/extended_dynamic_state2/README.adoc[like this one] demonstrate that.

=== Compute shading

If you're interested in doing compute shaders, the xref:../samples/api/compute_nbody/README.adoc[compute n-body] sample is a good place to start with. This one shows how to combine compute with graphics and how to properly synchronize between these two parts of the graphics pipeline. As more advanced use-case, asynchronous compute let's you overlap graphics and compute workloads on some devices to improve performance. This is demonstrated in the xref:../samples/performance/asnyc_compute/README.adoc[async compute sample].

// === Hardware accelerated ray tracing